<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Solar Word Game - Canvas Version</title>
        <link rel="stylesheet" href="./styles.css" />
    </head>
    <body>
        <h1 style="text-align: center; margin-bottom: 30px">Solar Word Game</h1>

        <div class="game-layout">
            <div class="game-area">
                <canvas id="gameCanvas" width="600" height="600"></canvas>

                <div class="controls">
                    <button class="check-button" onclick="checkAllPositions()">
                        Check for Words (Space)
                    </button>
                </div>

                <div id="results" class="results" style="display: none"></div>
            </div>

            <div class="sidebar">
                <div class="instructions">
                    <details>
                        <summary>
                            <strong>How to play:</strong>
                        </summary>
                        <p>
                            Click on an orbital ring to select it, then use
                            arrow keys to rotate. You can also click and drag
                            rings to rotate them. Find words by aligning
                            letters!
                        </p>

                        <div class="keyboard-hint">
                            <strong>Keyboard controls:</strong><br />
                            Click ring and press arrows keys to rotate<br />
                            Space bar to check for words
                        </div>
                    </details>
                </div>
                <div id="score-panel">
                    <div>
                        <h2 id="playerScore">0</h2>
                        <div class="rank" id="playerRank">Beginner</div>
                        <div class="score" id="wordCount">0 words found</div>
                    </div>
                </div>

                <div class="word-bank">
                    <h3>Word Bank</h3>
                    <div class="found-words" id="foundWords">
                        <em>Found words will appear here...</em>
                    </div>
                </div>
            </div>
        </div>

        <dialog id="ranksDialog" class="ranks-dialog">
            <div class="dialog-content">
                <div class="dialog-header">
                    <h2>Stellar Progression</h2>
                    <button class="close-button" onclick="closeRanksDialog()">
                        √ó
                    </button>
                </div>

                <div class="dialog-body">
                    <div class="ranks-grid">
                        <div class="rank-item current">
                            <div class="rank-icon">üå±</div>
                            <div class="rank-info">
                                <h3>Beginner</h3>
                                <p>0 points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">üëç</div>
                            <div class="rank-info">
                                <h3>Good</h3>
                                <p id="goodPoints">1+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">‚≠ê</div>
                            <div class="rank-info">
                                <h3>Great</h3>
                                <p id="greatPoints">10+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">üöÄ</div>
                            <div class="rank-info">
                                <h3>Voyager</h3>
                                <p id="voyagerPoints">20+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">‚ú®</div>
                            <div class="rank-info">
                                <h3>Stellar</h3>
                                <p id="stellarPoints">30+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">üî¥</div>
                            <div class="rank-info">
                                <h3>Red Giant</h3>
                                <p id="redGiantPoints">40+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">‚ö™</div>
                            <div class="rank-info">
                                <h3>White Dwarf</h3>
                                <p id="whiteDwarfPoints">50+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">üí•</div>
                            <div class="rank-info">
                                <h3>Supernova</h3>
                                <p id="supernovaPoints">70+ points</p>
                            </div>
                        </div>

                        <div class="rank-item">
                            <div class="rank-icon">üí´</div>
                            <div class="rank-info">
                                <h3>Neutron Star</h3>
                                <p id="neutronStarPoints">60+ points</p>
                            </div>
                        </div>

                        <div class="rank-item legendary">
                            <div class="rank-icon">üï≥Ô∏è</div>
                            <div class="rank-info">
                                <h3>Black Hole</h3>
                                <p id="blackHolePoints">80+ points</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </dialog>

        <script>
            // Constants - Ring diameters, colors, etc.
            const FIRST_RING_COLOR = "#ff6b6b";
            const SECOND_RING_COLOR = "#297a23";
            const THIRD_RING_COLOR = "#45b7d1";
            const FOURTH_RING_COLOR = "#9945d1";
            const FIFTH_RING_COLOR = "#9e297b";

            const FIRST_RING_RADIUS = 60;
            const SECOND_RING_RADIUS = 110;
            const THIRD_RING_RADIUS = 160;
            const FOURTH_RING_RADIUS = 210;
            const FIFTH_RING_RADIUS = 260;

            const RING_RADII = [
                FIRST_RING_RADIUS,
                SECOND_RING_RADIUS,
                THIRD_RING_RADIUS,
                FOURTH_RING_RADIUS,
                FIFTH_RING_RADIUS,
            ];

            // Game state - now with flexible letter positioning
            const gameState = {
                letters: [
                    {
                        letter: "E",
                        angle: 180,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "A",
                        angle: 180,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "M",
                        angle: 300,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "A",
                        angle: 300,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "C",
                        angle: 120,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "H",
                        angle: 120,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "A",
                        angle: 120,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "C",
                        angle: 60,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "H",
                        angle: 60,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "A",
                        angle: 60,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "I",
                        angle: 60,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "E",
                        angle: 30,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "A",
                        angle: 30,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "R",
                        angle: 30,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "L",
                        angle: 30,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "G",
                        angle: 240,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "R",
                        angle: 240,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "E",
                        angle: 240,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "Y",
                        angle: 240,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                ],
                rings: {
                    first: {
                        position: 0,
                        targetPosition: 0,
                        radius: FIRST_RING_RADIUS,
                        color: FIRST_RING_COLOR,
                    },
                    second: {
                        position: 0,
                        targetPosition: 0,
                        radius: SECOND_RING_RADIUS,
                        color: SECOND_RING_COLOR,
                    },
                    third: {
                        position: 0,
                        targetPosition: 0,
                        radius: THIRD_RING_RADIUS,
                        color: THIRD_RING_COLOR,
                    },
                    fourth: {
                        position: 0,
                        targetPosition: 0,
                        radius: FOURTH_RING_RADIUS,
                        color: FOURTH_RING_COLOR,
                    },
                    fifth: {
                        position: 0,
                        targetPosition: 0,
                        radius: FIFTH_RING_RADIUS,
                        color: FIFTH_RING_COLOR,
                    },
                },
                foundWords: new Set(),
                numWordsInGrandAlignment: 5,
                score: 0,
                maxScore: 100,
                dragState: null,
                selectedRing: null,
                center: { x: 300, y: 300 },
                sun: { letter: "T", radius: 20, color: "#ffdd44" },
                systemRotation: 0,
                hoveredArrow: null,
            };

            // Word list
            async function loadDictionary() {
                try {
                    const response = await fetch("./valid_words.txt");
                    const text = await response.text();

                    const words = text
                        .split("\n")
                        .map((word) => word.trim().toUpperCase())
                        .filter(
                            (word) => word.length >= 3 && word.length <= 11,
                        );

                    // console.log(`Loaded ${words.length} words`);
                    return new Set(words);
                } catch (error) {
                    console.error("Failed to load dictionary:", error);
                    return new Set(["SPACE", "STAR", "PLANET"]); // Fallback
                }
            }
            let dictionary;
            loadDictionary().then((raw_dictionary) => {
                dictionary = raw_dictionary;
            });

            // Canvas setup
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // Score dialog setup
            const showRanksDialogButton =
                document.getElementById("score-panel");
            const ranksDialog = document.getElementById("ranksDialog");

            // Animation loop
            function animate() {
                update();
                draw();
                requestAnimationFrame(animate);
            }

            function update() {
                // Smooth rotation animations with proper wraparound handling
                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    let diff = ring.targetPosition - ring.position;

                    // Handle wraparound: choose the shortest angular path
                    while (diff > 180) diff -= 360;
                    while (diff < -180) diff += 360;

                    if (Math.abs(diff) > 0.01) {
                        ring.position += diff * 0.15; // Smooth interpolation
                    }
                });
            }

            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw orbital rings (guidelines)
                drawOrbitalRings();

                // Draw reading direction indicators
                drawReadingIndicators();

                // Draw planets
                drawPlanets();

                // Draw sun
                drawSun();

                // Draw rotation arrows
                drawRotationArrows();

                // Draw any word visualization
                drawWordLines();
            }

            function drawOrbitalRings() {
                // Draw rings based on unique radii from letters
                const radii = [
                    ...new Set(
                        Object.values(gameState.rings).map(
                            (ring) => ring.radius,
                        ),
                    ),
                ];
                radii.forEach((radius) => {
                    const ringName = Object.keys(gameState.rings).find(
                        (name) => gameState.rings[name].radius === radius,
                    );
                    const isSelected = gameState.selectedRing === ringName;

                    ctx.strokeStyle = isSelected ? "#ffdd44" : "#444";
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.setLineDash(isSelected ? [] : [5, 5]);

                    ctx.beginPath();
                    ctx.arc(
                        gameState.center.x,
                        gameState.center.y,
                        radius,
                        0,
                        Math.PI * 2,
                    );
                    ctx.stroke();
                });

                ctx.setLineDash([]);
            }

            function drawReadingIndicators() {
                ctx.strokeStyle = "#666";
                ctx.lineWidth = 1;
                ctx.font = "10px Arial";
                ctx.fillStyle = "#888";

                // Draw subtle lines at all 12 positions
                for (let pos = 0; pos < 8; pos++) {
                    const angle = ((pos * 45 - 90) * Math.PI) / 180;

                    if (pos % 2 === 1) {
                        // Show main positions (12, 3, 6, 9)
                        const x1 = gameState.center.x + 60 * Math.cos(angle);
                        const y1 = gameState.center.y + 60 * Math.sin(angle);
                        const x2 = gameState.center.x + 300 * Math.cos(angle);
                        const y2 = gameState.center.y + 300 * Math.sin(angle);

                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = "#ffdd44";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            }

            function drawPlanets() {
                gameState.letters.forEach((letterObj) => {
                    // Calculate current position based on ring rotation
                    const ringRotation =
                        (gameState.rings[letterObj.ring].position * Math.PI) /
                        180;
                    const totalAngle =
                        (letterObj.angle * Math.PI) / 180 +
                        ringRotation -
                        Math.PI / 2;

                    const x =
                        gameState.center.x +
                        letterObj.radius * Math.cos(totalAngle);
                    const y =
                        gameState.center.y +
                        letterObj.radius * Math.sin(totalAngle);

                    // Planet body
                    ctx.fillStyle = letterObj.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.fill();

                    // Planet border
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Letter
                    ctx.fillStyle = "white";
                    ctx.font = "bold 22px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "second";
                    ctx.fillText(letterObj.letter, x, y);
                });
            }

            function drawSun() {
                const sun = gameState.sun;

                // Sun glow
                const gradient = ctx.createRadialGradient(
                    gameState.center.x,
                    gameState.center.y,
                    0,
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius + 10,
                );
                gradient.addColorStop(0, "#ffdd44");
                gradient.addColorStop(0.7, "#ffaa00");
                gradient.addColorStop(1, "rgba(255, 170, 0, 0)");

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius + 10,
                    0,
                    Math.PI * 2,
                );
                ctx.fill();

                // Sun body
                ctx.fillStyle = sun.color;
                ctx.beginPath();
                ctx.arc(
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius,
                    0,
                    Math.PI * 2,
                );
                ctx.fill();

                // Sun border
                ctx.strokeStyle = "#ffaa00";
                ctx.lineWidth = 3;
                ctx.stroke();

                // Sun letter
                ctx.fillStyle = "#333";
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(
                    gameState.sun.letter,
                    gameState.center.x,
                    gameState.center.y,
                );
            }

            function drawWordLines() {
                // TODO
                // This will show visual connections for found words
                // Implementation can be added later for visual feedback
            }

            function drawRotationArrows() {
                const arrowSize = 30;
                const cornerOffset = 15;
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                // Left top arrow (counter-clockwise)
                const leftX = cornerOffset + arrowSize / 2;
                const leftY = cornerOffset + arrowSize / 2;
                drawRotationArrow(leftX, leftY, "left");

                // Right top arrow (clockwise)
                const rightX = canvasWidth - cornerOffset - arrowSize / 2;
                const rightY = cornerOffset + arrowSize / 2;
                drawRotationArrow(rightX, rightY, "right");
            }

            function drawRotationArrow(x, y, direction) {
                const radius = 25;
                const isHovered = gameState.hoveredArrow === direction;

                ctx.save();

                // Draw background circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = isHovered
                    ? "rgba(78, 205, 196, 0.3)"
                    : "rgba(26, 26, 62, 0.9)";
                ctx.fill();

                // Draw border
                ctx.strokeStyle = isHovered ? "#ffdd44" : "#4ecdc4";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw the arrow symbol
                ctx.strokeStyle = isHovered ? "#ffdd44" : "#4ecdc4";
                ctx.fillStyle = isHovered ? "#ffdd44" : "#4ecdc4";
                ctx.lineWidth = 2.5;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                if (direction === "left") {
                    // Counter-clockwise: upward triangle on the left with arc connecting to bottom

                    // Draw upward-pointing triangle on the left
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y - 12); // Top point
                    ctx.lineTo(x - 12, y - 4); // Bottom left
                    ctx.lineTo(x - 4, y - 4); // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Draw arc connecting from triangle bottom, sweeping counter-clockwise
                    ctx.beginPath();
                    ctx.arc(x, y, 10, Math.PI * 1.2, Math.PI * 0.2, false);
                    ctx.stroke();
                } else {
                    // Clockwise: upward triangle on the right with arc connecting to bottom

                    // Draw upward-pointing triangle on the right
                    ctx.beginPath();
                    ctx.moveTo(x + 8, y - 12); // Top point
                    ctx.lineTo(x + 4, y - 4); // Bottom left
                    ctx.lineTo(x + 12, y - 4); // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Draw arc connecting from triangle bottom, sweeping clockwise
                    ctx.beginPath();
                    ctx.arc(x, y, 10, Math.PI * 0.8, Math.PI * 1.8, false);
                    ctx.stroke();
                }

                ctx.restore();
            }

            // Input handling
            canvas.addEventListener("mousedown", handleMouseDown);
            canvas.addEventListener("mousemove", handleMouseMove);
            canvas.addEventListener("mouseup", handleMouseUp);
            canvas.addEventListener("touchstart", handleTouchStart);
            canvas.addEventListener("touchmove", handleTouchMove);
            canvas.addEventListener("touchend", handleTouchEnd);

            // Keyboard controls
            document.addEventListener("keydown", handleKeyDown);

            // Rank board input handling
            showRanksDialogButton.addEventListener("click", () => {
                ranksDialog.showModal();
            });

            function handleKeyDown(e) {
                if (!gameState.selectedRing) return;

                switch (e.code) {
                    case "ArrowLeft":
                        e.preventDefault();
                        rotateRing(gameState.selectedRing, -1);
                        break;
                    case "ArrowRight":
                        e.preventDefault();
                        rotateRing(gameState.selectedRing, 1);
                        break;
                    case "ArrowUp":
                        e.preventDefault();
                        gameState.selectedRing = getNextRing(
                            gameState.selectedRing,
                        );
                        break;
                    case "ArrowDown":
                        e.preventDefault();
                        gameState.selectedRing = getPrevoiusRing(
                            gameState.selectedRing,
                        );
                        break;
                    case "Space":
                        e.preventDefault();
                        checkAllPositions();
                        break;
                }
            }

            function handleMouseDown(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                startDrag(x, y);
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // Check arrow hover
                const prevHoveredArrow = gameState.hoveredArrow;
                gameState.hoveredArrow = getHoveredArrow(x, y);

                // Update cursor
                if (gameState.hoveredArrow) {
                    canvas.style.cursor = "pointer";
                } else if (!gameState.dragState) {
                    canvas.style.cursor = "pointer";
                }

                // Redraw if hover state changed
                if (prevHoveredArrow !== gameState.hoveredArrow) {
                    // No need to call draw() here as it's called by animate()
                }

                updateDrag(x, y);
            }

            function handleMouseUp(e) {
                endDrag();
            }

            function handleTouchStart(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;
                startDrag(x, y);
            }

            function handleTouchMove(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;
                updateDrag(x, y);
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                endDrag();
            }

            function startDrag(x, y) {
                // Check if clicking on arrow first
                const clickedArrow = getHoveredArrow(x, y);
                if (clickedArrow) {
                    const rotation = clickedArrow === "left" ? -30 : 30;
                    rotateSystem(rotation);
                    return; // Don't start ring drag
                }

                // Existing ring selection logic
                const distance = Math.sqrt(
                    (x - gameState.center.x) ** 2 +
                        (y - gameState.center.y) ** 2,
                );

                let targetRing = null;
                let minDiff = Infinity;

                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    const diff = Math.abs(distance - ring.radius);
                    if (diff < 30 && diff < minDiff) {
                        minDiff = diff;
                        targetRing = ringName;
                    }
                });

                if (targetRing) {
                    gameState.selectedRing = targetRing;
                    const angle = Math.atan2(
                        y - gameState.center.y,
                        x - gameState.center.x,
                    );
                    gameState.dragState = {
                        ring: targetRing,
                        startAngle: angle,
                        startPosition: gameState.rings[targetRing].position,
                    };
                    canvas.style.cursor = "grabbing";
                } else {
                    gameState.selectedRing = null;
                }
            }

            function updateDrag(x, y) {
                if (!gameState.dragState) return;

                const angle = Math.atan2(
                    y - gameState.center.y,
                    x - gameState.center.x,
                );

                // Calculate the shortest angular distance
                let deltaAngle = angle - gameState.dragState.startAngle;

                // Normalize to [-œÄ, œÄ] range to prevent wrapping issues
                while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;

                const deltaPosition = (deltaAngle * 180) / Math.PI;
                let newPosition =
                    gameState.dragState.startPosition + deltaPosition;

                // Snap to nearest 30-degree increment
                newPosition = Math.round(newPosition / 30) * 30;

                gameState.rings[gameState.dragState.ring].targetPosition =
                    newPosition;
            }

            function endDrag() {
                gameState.dragState = null;
                canvas.style.cursor = "pointer";
            }

            function closeRanksDialog() {
                ranksDialog.close();
            }

            // Scoring system
            const RANKS = [
                { name: "Beginner", min: 0 },
                { name: "Good", min: Math.floor(gameState.maxScore * 0.1) },
                { name: "Great", min: Math.floor(gameState.maxScore * 0.2) },
                { name: "Voyager", min: Math.floor(gameState.maxScore * 0.3) },
                { name: "Stellar", min: Math.floor(gameState.maxScore * 0.4) },
                {
                    name: "Red Giant",
                    min: Math.floor(gameState.maxScore * 0.5),
                },
                {
                    name: "White Dwarf",
                    min: Math.floor(gameState.maxScore * 0.6),
                },
                {
                    name: "Supernova",
                    min: Math.floor(gameState.maxScore * 0.7),
                },
                {
                    name: "Neutron Star",
                    min: Math.floor(gameState.maxScore * 0.8),
                },
                { name: "Black Hole", min: gameState.maxScore },
            ];

            function calculateWordScore(word, hasSun = false) {
                let baseScore;
                const length = word.length;

                // Base scoring (Spelling Bee style)
                if (length === 3) {
                    baseScore = 1;
                } else {
                    baseScore = length; // 4+ letters get 1 point per letter
                }

                // Bonuses
                if (hasSun) baseScore += 1; // Sun letter bonus

                return baseScore;
            }

            function getRank(score) {
                for (let i = RANKS.length - 1; i >= 0; i--) {
                    if (score >= RANKS[i].min) {
                        return RANKS[i].name;
                    }
                }
                return "Beginner";
            }

            function updateScoreDisplay() {
                document.getElementById("playerScore").textContent =
                    gameState.score;
                document.getElementById("playerRank").textContent = getRank(
                    gameState.score,
                );
                document.getElementById("wordCount").textContent =
                    `${gameState.foundWords.size} words found`;

                // TODO: update current rank highlight
            }

            function rotateRing(ringName, direction) {
                const ring = gameState.rings[ringName];
                let newPosition = ring.targetPosition + direction * 30;

                ring.targetPosition = newPosition;
            }

            function rotateSystem(degrees) {
                gameState.systemRotation += degrees;

                // Keep rotation between 0-360
                while (gameState.systemRotation < 0)
                    gameState.systemRotation += 360;
                while (gameState.systemRotation >= 360)
                    gameState.systemRotation -= 360;

                // Rotate all rings by the specified amount
                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    ring.targetPosition += degrees;

                    // Keep positions normalized
                    while (ring.targetPosition < 0) ring.targetPosition += 360;
                    while (ring.targetPosition >= 360)
                        ring.targetPosition -= 360;
                });
            }

            function getLettersAtPosition(position) {
                const positionAngle = position * 30;
                const oppositeAngle = (positionAngle + 180) % 360;

                // Find letters at the position angle
                const positionLetters = [];
                // Find letters at the opposite angle
                const oppositeLetters = [];

                gameState.letters.forEach((letterObj) => {
                    const ringRotation =
                        gameState.rings[letterObj.ring].position;
                    const currentAngle = (letterObj.angle + ringRotation) % 360;
                    const normalizedCurrentAngle =
                        currentAngle < 0 ? currentAngle + 360 : currentAngle;

                    // Check if aligns with position angle
                    const positionDiff = Math.abs(
                        normalizedCurrentAngle - positionAngle,
                    );
                    const positionWrappedDiff = Math.min(
                        positionDiff,
                        360 - positionDiff,
                    );

                    if (positionWrappedDiff < 15) {
                        positionLetters.push({
                            letter: letterObj.letter,
                            radius: letterObj.radius,
                        });
                    }

                    // Check if aligns with opposite angle
                    const oppositeDiff = Math.abs(
                        normalizedCurrentAngle -
                            (oppositeAngle < 0
                                ? oppositeAngle + 360
                                : oppositeAngle),
                    );
                    const oppositeWrappedDiff = Math.min(
                        oppositeDiff,
                        360 - oppositeDiff,
                    );

                    if (oppositeWrappedDiff < 15) {
                        oppositeLetters.push({
                            letter: letterObj.letter,
                            radius: letterObj.radius,
                        });
                    }
                });

                // Add in blanks for positionLetters and oppositeLetters
                for (let radius of RING_RADII) {
                    if (
                        !positionLetters.some(
                            (letterObj) => letterObj.radius == radius,
                        )
                    ) {
                        positionLetters.push({
                            letter: " ",
                            radius,
                        });
                    }

                    if (
                        !oppositeLetters.some(
                            (letterObj) => letterObj.radius == radius,
                        )
                    ) {
                        oppositeLetters.push({
                            letter: " ",
                            radius,
                        });
                    }
                }

                // Sort position letters by radius (outermost to innermost)
                positionLetters.sort((a, b) => b.radius - a.radius);

                // Sort opposite letters by radius in reverse (innermost to outermost)
                oppositeLetters.sort((a, b) => a.radius - b.radius);

                // Build the sequence: position letters + sun + opposite letters
                const fullSequence = [];

                // Add position side letters
                positionLetters.forEach((item) =>
                    fullSequence.push(item.letter),
                );

                // Add sun in the middle
                fullSequence.push(gameState.sun.letter);

                // Add opposite side letters
                oppositeLetters.forEach((item) =>
                    fullSequence.push(item.letter),
                );

                return fullSequence;
            }

            function findWordsInAlignment(letters, position) {
                const words = [];
                const positionAngle = position * 30;

                // Determine reading direction based on sector
                const normalizedAngle = ((positionAngle % 360) + 360) % 360;
                const isVerticalSector =
                    normalizedAngle >= 315 ||
                    normalizedAngle <= 45 ||
                    (normalizedAngle >= 135 && normalizedAngle <= 225);

                // Check all possible starting positions and lengths in the ordered sequence
                // Determine if this word includes the sun
                const includesSun = letters.includes(gameState.sun.letter);

                // Check if this forms a valid word
                const potentialWords = letters.join("").trim().split(" ");
                for (const word of potentialWords) {
                    if (dictionary.has(word)) {
                        words.push({
                            word: word,
                            direction: isVerticalSector
                                ? "top-to-bottom"
                                : "left-to-right",
                            letters,
                            includesSun: includesSun,
                        });
                    }
                }

                // Remove duplicates based on word text
                const uniqueWords = [];
                const seen = new Set();
                words.forEach((wordObj) => {
                    if (!seen.has(wordObj.word)) {
                        seen.add(wordObj.word);
                        uniqueWords.push(wordObj);
                    }
                });

                return uniqueWords;
            }

            function checkAllPositions() {
                const allWords = [];
                const wordDetails = [];
                const positionsToCheck = [0, 1, 8, 9, 10, 11];
                let newWordsFound = false;
                let bonusScore = 0;

                for (let position of positionsToCheck) {
                    const letters = getLettersAtPosition(position);
                    const wordObjects = findWordsInAlignment(letters, position);

                    if (wordObjects.length > 0) {
                        // Add words found to allWords to check for bonuses later
                        wordObjects.forEach((wordObj) => {
                            allWords.push(wordObj.word);

                            // Calculate score for new words
                            if (!gameState.foundWords.has(wordObj.word)) {
                                newWordsFound = true;
                                const hasSun = wordObj.word.includes(
                                    gameState.sun.letter,
                                );
                                let wordScore = calculateWordScore(
                                    wordObj.word,
                                    hasSun,
                                );
                                gameState.score += wordScore;
                            }
                        });

                        wordDetails.push({
                            position: position,
                            letters: letters,
                            words: wordObjects,
                        });
                    }
                }

                // Check for multi-word bonus at this position
                const isMultiWord = allWords.length > 1;
                const isGrandAlignment =
                    allWords.length == gameState.numWordsInGrandAlignment;

                // 2 bonus points for each additional word found!
                if (allWords.length > 1 && !isGrandAlignment) {
                    bonusScore +=
                        2 *
                        (gameState.numWordsInGrandAlignment - allWords.length);
                } else if (isGrandAlignment) bonusScore += 15;

                // Apply all bonus scores (multi-word, grand alignment, etc)
                gameState.score += bonusScore;

                // Add to word bank
                allWords.forEach((word) => {
                    gameState.foundWords.add(word);
                });

                updateWordBank();
                updateScoreDisplay();

                if (newWordsFound) {
                    // TODO:
                    // Brief score animation could go here
                }
            }

            function updateWordBank() {
                const foundWordsEl = document.getElementById("foundWords");

                if (gameState.foundWords.size === 0) {
                    foundWordsEl.innerHTML =
                        "<em>Found words will appear here...</em>";
                } else {
                    foundWordsEl.innerHTML = "";

                    gameState.foundWords.forEach((word) => {
                        const wordEl = document.createElement("div");
                        wordEl.className = "word-item";
                        wordEl.textContent = word;
                        foundWordsEl.appendChild(wordEl);
                    });
                }
            }

            // Helper Functions
            function getNextRing(currentRing) {
                switch (currentRing) {
                    case "first":
                        return "second";
                    case "second":
                        return "third";
                    case "third":
                        return "fourth";
                    case "fourth":
                        return "fifth";
                    case "fifth":
                        return "first";
                    default:
                        return null;
                }
            }

            function getPrevoiusRing(currentRing) {
                switch (currentRing) {
                    case "first":
                        return "fifth";
                    case "second":
                        return "first";
                    case "third":
                        return "second";
                    case "fourth":
                        return "third";
                    case "fifth":
                        return "fourth";
                    default:
                        return null;
                }
            }

            function getHoveredArrow(x, y) {
                const arrowRadius = 25;
                const cornerOffset = 15;
                const arrowSize = 30;

                // Left arrow position
                const leftX = cornerOffset + arrowSize / 2;
                const leftY = cornerOffset + arrowSize / 2;

                // Right arrow position
                const rightX = canvas.width - cornerOffset - arrowSize / 2;
                const rightY = cornerOffset + arrowSize / 2;

                // Check left arrow
                const leftDist = Math.sqrt((x - leftX) ** 2 + (y - leftY) ** 2);
                if (leftDist <= arrowRadius) {
                    return "left";
                }

                // Check right arrow
                const rightDist = Math.sqrt(
                    (x - rightX) ** 2 + (y - rightY) ** 2,
                );
                if (rightDist <= arrowRadius) {
                    return "right";
                }

                return null;
            }

            function shufflePlanets() {
                const rings = gameState.rings;
                for (let ring of Object.keys(rings)) {
                    let randomRotation = 30 * Math.floor(12 * Math.random());
                    rings[ring].targetPosition += randomRotation;
                }
            }

            function initializeRanks() {
                const goodPoints = document.getElementById("goodPoints");
                const greatPoints = document.getElementById("greatPoints");
                const voyagerPoints = document.getElementById("voyagerPoints");
                const stellarPoints = document.getElementById("stellarPoints");
                const redGiantPoints =
                    document.getElementById("redGiantPoints");
                const whiteDwarfPoints =
                    document.getElementById("whiteDwarfPoints");
                const supernovaPoints =
                    document.getElementById("supernovaPoints");
                const neutronStarPoints =
                    document.getElementById("neutronStarPoints");
                const blackHolePoints =
                    document.getElementById("blackHolePoints");

                goodPoints.textContent = RANKS[1].min + " points";
                greatPoints.textContent = RANKS[2].min + " points";
                voyagerPoints.textContent = RANKS[3].min + " points";
                stellarPoints.textContent = RANKS[4].min + " points";
                redGiantPoints.textContent = RANKS[5].min + " points";
                whiteDwarfPoints.textContent = RANKS[6].min + " points";
                supernovaPoints.textContent = RANKS[7].min + " points";
                neutronStarPoints.textContent = RANKS[8].min + " points";
                blackHolePoints.textContent = RANKS[9].min + "+ points";
            }

            function initializeGame() {
                // Initialize the game
                updateScoreDisplay();
                initializeRanks();
                shufflePlanets();
                animate();
            }

            // Start the game!
            initializeGame();
        </script>
    </body>
</html>
