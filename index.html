<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>The Daily Planet</title>
        <link rel="stylesheet" href="./styles.css" />
    </head>
    <body>
        <h1 style="text-align: center; margin-bottom: 30px">
            The Daily Planet
        </h1>

        <div class="game-layout">
            <div class="game-area">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
                <div class="controls">
                    <button class="check-button" onclick="checkAllPositions()">
                        Check for Words (Space)
                    </button>
                </div>

                <div id="results" class="results" style="display: none"></div>
            </div>

            <div class="sidebar">
                <!-- Help button -->
                <button
                    id="helpButton"
                    class="help-button"
                    onclick="openHelpDialog()"
                    title="How to play"
                >
                    ?
                </button>
                <div id="score-panel">
                    <div>
                        <h2 id="playerScore">0</h2>
                        <div class="rank" id="playerRank">Beginner</div>
                        <div class="score" id="wordCount">0 words found</div>
                    </div>
                </div>

                <div class="word-bank">
                    <h3>Word Bank</h3>
                    <div class="found-words" id="foundWords">
                        <em>Found words will appear here...</em>
                    </div>
                </div>
            </div>
        </div>

        <dialog id="ranksDialog" class="ranks-dialog">
            <div class="dialog-content">
                <div class="dialog-header">
                    <h2>Stellar Progression</h2>
                    <button class="close-button" onclick="closeRanksDialog()">
                        √ó
                    </button>
                </div>

                <div class="dialog-body">
                    <div class="ranks-grid">
                        <div class="rank-item current-rank" id="rankBeginner">
                            <div class="rank-icon">üå±</div>
                            <div class="rank-info">
                                <h3>Beginner</h3>
                                <p>0 points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankGood">
                            <div class="rank-icon">üëç</div>
                            <div class="rank-info">
                                <h3>Good</h3>
                                <p id="goodPoints">1+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankGreat">
                            <div class="rank-icon">‚≠ê</div>
                            <div class="rank-info">
                                <h3>Great</h3>
                                <p id="greatPoints">10+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankVoyager">
                            <div class="rank-icon">üöÄ</div>
                            <div class="rank-info">
                                <h3>Voyager</h3>
                                <p id="voyagerPoints">20+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankStellar">
                            <div class="rank-icon">‚ú®</div>
                            <div class="rank-info">
                                <h3>Stellar</h3>
                                <p id="stellarPoints">30+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankRedGiant">
                            <div class="rank-icon">üî¥</div>
                            <div class="rank-info">
                                <h3>Red Giant</h3>
                                <p id="redGiantPoints">40+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankWhiteDwarf">
                            <div class="rank-icon">‚ö™</div>
                            <div class="rank-info">
                                <h3>White Dwarf</h3>
                                <p id="whiteDwarfPoints">50+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankSupernova">
                            <div class="rank-icon">üí•</div>
                            <div class="rank-info">
                                <h3>Supernova</h3>
                                <p id="supernovaPoints">70+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankNeutronStar">
                            <div class="rank-icon">üí´</div>
                            <div class="rank-info">
                                <h3>Neutron Star</h3>
                                <p id="neutronStarPoints">60+ points</p>
                            </div>
                        </div>

                        <div class="rank-item" id="rankBlackHole">
                            <div class="rank-icon">üï≥Ô∏è</div>
                            <div class="rank-info">
                                <h3>Black Hole</h3>
                                <p id="blackHolePoints">80+ points</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </dialog>
        <!-- Help Dialog -->
        <dialog id="helpDialog" class="help-dialog">
            <div class="dialog-content">
                <div class="dialog-header">
                    <h2>How to Play</h2>
                    <button class="close-button" onclick="closeHelpDialog()">
                        √ó
                    </button>
                </div>

                <div class="dialog-body">
                    <div class="help-sections">
                        <div class="help-section">
                            <h3>üéØ Objective</h3>
                            <p>
                                Rotate the orbital rings to align letters and
                                form words! Find all the hidden words to achieve
                                the highest rank.
                            </p>
                        </div>

                        <div class="help-section">
                            <h3>üïπÔ∏è Controls</h3>
                            <ul>
                                <li>
                                    <strong>Click & Drag:</strong> Rotate rings
                                    by dragging them
                                </li>
                                <li>
                                    <strong>Click Ring:</strong> Select a ring,
                                    then use arrow keys
                                </li>
                                <li>
                                    <strong>‚Üë/‚Üì Keys:</strong> Switch between
                                    rings
                                </li>
                                <li>
                                    <strong>‚Üê/‚Üí Keys:</strong> Rotate selected
                                    ring
                                </li>
                                <li><strong>Space:</strong> Check for words</li>
                                <li>
                                    <strong>Corner Arrows:</strong> Rotate
                                    entire system
                                </li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìñ Word Formation</h3>
                            <p>
                                Words are formed by letters that align on the
                                same line passing through the center. The sun
                                letter can be part of words too!
                            </p>
                        </div>

                        <div class="help-section">
                            <h3>üèÜ Scoring</h3>
                            <ul>
                                <li>
                                    <strong>3-letter words:</strong> 1 point
                                </li>
                                <li>
                                    <strong>4+ letter words:</strong> 1 point
                                    per letter
                                </li>
                                <li>
                                    <strong>Words with sun letter:</strong> +1
                                    bonus
                                </li>
                                <li>
                                    <strong>Multiple words:</strong> +2 per
                                    extra word
                                </li>
                                <li>
                                    <strong>Grand Alignment:</strong> +15 bonus!
                                </li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üåü Grand Alignment</h3>
                            <p>
                                The ultimate goal! Find the special
                                configuration where you can make
                                <strong>6 words</strong> at once. This triggers
                                a celebration and awards a huge bonus!
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </dialog>

        <script>
            // Constants - Ring diameters, colors, etc.
            const FIRST_RING_COLOR = "#ff6b6b";
            const SECOND_RING_COLOR = "#297a23";
            const THIRD_RING_COLOR = "#45b7d1";
            const FOURTH_RING_COLOR = "#9945d1";
            const FIFTH_RING_COLOR = "#9e297b";

            const FIRST_RING_RADIUS = 60;
            const SECOND_RING_RADIUS = 110;
            const THIRD_RING_RADIUS = 160;
            const FOURTH_RING_RADIUS = 210;
            const FIFTH_RING_RADIUS = 260;

            const RING_RADII = [
                FIRST_RING_RADIUS,
                SECOND_RING_RADIUS,
                THIRD_RING_RADIUS,
                FOURTH_RING_RADIUS,
                FIFTH_RING_RADIUS,
            ];

            const LOCAL_STORAGE_KEY = "solarWordGameState";

            // Game state - now with flexible letter positioning
            let gameState = {
                gameId: "The Ocean and The Sea",
                letters: [
                    {
                        letter: "C",
                        angle: 270,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "O",
                        angle: 270,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "R",
                        angle: 270,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "L",
                        angle: 90,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "O",
                        angle: 330,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "C",
                        angle: 330,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "E",
                        angle: 330,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "N",
                        angle: 150,
                        radius: 60,
                        ring: "first",
                        color: "#ff6b6b",
                    },
                    {
                        letter: "S",
                        angle: 120,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "E",
                        angle: 120,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "A",
                        angle: 120,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "W",
                        angle: 180,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "A",
                        angle: 180,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "V",
                        angle: 180,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "E",
                        angle: 180,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "R",
                        angle: 60,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                    {
                        letter: "E",
                        angle: 60,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "E",
                        angle: 60,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "F",
                        angle: 60,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "G",
                        angle: 240,
                        radius: 260,
                        ring: "fifth",
                        color: "#9e297b",
                    },
                    {
                        letter: "U",
                        angle: 240,
                        radius: 210,
                        ring: "fourth",
                        color: "#9945d1",
                    },
                    {
                        letter: "L",
                        angle: 240,
                        radius: 160,
                        ring: "third",
                        color: "#45b7d1",
                    },
                    {
                        letter: "F",
                        angle: 240,
                        radius: 110,
                        ring: "second",
                        color: "#297a23",
                    },
                ],
                rings: {
                    first: {
                        position: 0,
                        targetPosition: 0,
                        radius: FIRST_RING_RADIUS,
                        color: FIRST_RING_COLOR,
                    },
                    second: {
                        position: 0,
                        targetPosition: 0,
                        radius: SECOND_RING_RADIUS,
                        color: SECOND_RING_COLOR,
                    },
                    third: {
                        position: 0,
                        targetPosition: 0,
                        radius: THIRD_RING_RADIUS,
                        color: THIRD_RING_COLOR,
                    },
                    fourth: {
                        position: 0,
                        targetPosition: 0,
                        radius: FOURTH_RING_RADIUS,
                        color: FOURTH_RING_COLOR,
                    },
                    fifth: {
                        position: 0,
                        targetPosition: 0,
                        radius: FIFTH_RING_RADIUS,
                        color: FIFTH_RING_COLOR,
                    },
                },
                foundWords: new Set(),
                numWordsInGrandAlignment: 6,
                score: 0,
                maxScore: 127,
                dragState: null,
                selectedRing: "first",
                center: { x: 300, y: 300 },
                sun: { letter: "A", radius: 20, color: "#ffdd44" },
                systemRotation: 0,
                hoveredArrow: null,
                rank: "Beginner",
                grandAlignmentAnimation: {
                    active: false,
                    startTime: 0,
                    duration: 5000, // 3 seconds
                    particles: [],
                },
            };

            // Scoring system
            const RANKS = [
                { name: "Beginner", min: 0, rankId: "rankBeginner" },
                {
                    name: "Good",
                    min: Math.floor(gameState.maxScore * 0.1),
                    rankId: "rankGood",
                },
                {
                    name: "Great",
                    min: Math.floor(gameState.maxScore * 0.2),
                    rankId: "rankGreat",
                },
                {
                    name: "Voyager",
                    min: Math.floor(gameState.maxScore * 0.3),
                    rankId: "rankVoyager",
                },
                {
                    name: "Stellar",
                    min: Math.floor(gameState.maxScore * 0.4),
                    rankId: "rankStellar",
                },
                {
                    name: "Red Giant",
                    min: Math.floor(gameState.maxScore * 0.5),
                    rankId: "rankRedGiant",
                },
                {
                    name: "White Dwarf",
                    min: Math.floor(gameState.maxScore * 0.6),
                    rankId: "rankWhiteDwarf",
                },
                {
                    name: "Supernova",
                    min: Math.floor(gameState.maxScore * 0.7),
                    rankId: "rankSupernova",
                },
                {
                    name: "Neutron Star",
                    min: Math.floor(gameState.maxScore * 0.8),
                    rankId: "rankNeutronStar",
                },
                {
                    name: "Black Hole",
                    min: gameState.maxScore,
                    rankId: "rankBlackHole",
                },
            ];

            // Word list
            async function loadDictionary() {
                try {
                    const response = await fetch("./valid_words.txt");
                    const text = await response.text();

                    const words = text
                        .split("\n")
                        .map((word) => word.trim().toUpperCase())
                        .filter(
                            (word) => word.length >= 3 && word.length <= 11,
                        );

                    // console.log(`Loaded ${words.length} words`);
                    return new Set(words);
                } catch (error) {
                    console.error("Failed to load dictionary:", error);
                    return new Set(["SPACE", "STAR", "PLANET"]); // Fallback
                }
            }
            let dictionary;
            loadDictionary().then((raw_dictionary) => {
                dictionary = raw_dictionary;
                // runFindAllPossibleWords(gameState, dictionary);
            });

            // Canvas setup
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // Score dialog setup
            const showRanksDialogButton =
                document.getElementById("score-panel");
            const ranksDialog = document.getElementById("ranksDialog");

            // Animation loop
            function animate() {
                update();
                draw();
                requestAnimationFrame(animate);
            }

            function update() {
                // Smooth rotation animations with proper wraparound handling
                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    let diff = ring.targetPosition - ring.position;

                    // Handle wraparound: choose the shortest angular path
                    while (diff > 180) diff -= 360;
                    while (diff < -180) diff += 360;

                    if (Math.abs(diff) > 0.01) {
                        ring.position += diff * 0.15; // Smooth interpolation
                    }
                });

                // Update grand alignment animation
                updateGrandAlignmentAnimation();
            }

            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw orbital rings (guidelines)
                drawOrbitalRings();

                // Draw reading direction indicators
                drawReadingIndicators();

                // Draw planets
                drawPlanets();

                // Draw sun
                drawSun();

                // Draw rotation arrows
                drawRotationArrows();

                // Draw grand alignment animation (connection lines and particles)
                drawGrandAlignmentAnimation();

                // Draw any word visualization
                drawWordLines();
            }

            function drawOrbitalRings() {
                // Draw rings based on unique radii from letters
                const radii = [
                    ...new Set(
                        Object.values(gameState.rings).map(
                            (ring) => ring.radius,
                        ),
                    ),
                ];
                radii.forEach((radius) => {
                    const ringName = Object.keys(gameState.rings).find(
                        (name) => gameState.rings[name].radius === radius,
                    );
                    const isSelected = gameState.selectedRing === ringName;

                    ctx.strokeStyle = isSelected ? "#ffdd44" : "#444";
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.setLineDash(isSelected ? [] : [5, 5]);

                    ctx.beginPath();
                    ctx.arc(
                        gameState.center.x,
                        gameState.center.y,
                        radius,
                        0,
                        Math.PI * 2,
                    );
                    ctx.stroke();
                });

                ctx.setLineDash([]);
            }

            function drawReadingIndicators() {
                ctx.strokeStyle = "#666";
                ctx.lineWidth = 1;
                ctx.font = "10px Arial";
                ctx.fillStyle = "#888";

                // Draw subtle lines at all 12 positions
                for (let pos = 0; pos < 8; pos++) {
                    const angle = ((pos * 45 - 90) * Math.PI) / 180;

                    if (pos % 2 === 1) {
                        // Show main positions (12, 3, 6, 9)
                        const x1 = gameState.center.x + 60 * Math.cos(angle);
                        const y1 = gameState.center.y + 60 * Math.sin(angle);
                        const x2 = gameState.center.x + 300 * Math.cos(angle);
                        const y2 = gameState.center.y + 300 * Math.sin(angle);

                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = "#ffdd44";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            }

            function drawPlanets() {
                gameState.letters.forEach((letterObj) => {
                    // Calculate current position based on ring rotation
                    const ringRotation =
                        (gameState.rings[letterObj.ring].position * Math.PI) /
                        180;
                    const totalAngle =
                        (letterObj.angle * Math.PI) / 180 +
                        ringRotation -
                        Math.PI / 2;

                    const x =
                        gameState.center.x +
                        letterObj.radius * Math.cos(totalAngle);
                    const y =
                        gameState.center.y +
                        letterObj.radius * Math.sin(totalAngle);

                    // Planet body
                    ctx.fillStyle = letterObj.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.fill();

                    // Planet border
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Letter
                    ctx.fillStyle = "white";
                    ctx.font = "bold 22px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "second";
                    ctx.fillText(letterObj.letter, x, y);
                });
            }

            function drawSun() {
                const sun = gameState.sun;

                // Sun glow
                const gradient = ctx.createRadialGradient(
                    gameState.center.x,
                    gameState.center.y,
                    0,
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius + 10,
                );
                gradient.addColorStop(0, "#ffdd44");
                gradient.addColorStop(0.7, "#ffaa00");
                gradient.addColorStop(1, "rgba(255, 170, 0, 0)");

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius + 10,
                    0,
                    Math.PI * 2,
                );
                ctx.fill();

                // Sun body
                ctx.fillStyle = sun.color;
                ctx.beginPath();
                ctx.arc(
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius,
                    0,
                    Math.PI * 2,
                );
                ctx.fill();

                // Sun border
                ctx.strokeStyle = "#ffaa00";
                ctx.lineWidth = 3;
                ctx.stroke();

                // Sun letter
                ctx.fillStyle = "#333";
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(
                    gameState.sun.letter,
                    gameState.center.x,
                    gameState.center.y,
                );
            }

            function drawWordLines() {
                // TODO
                // This will show visual connections for found words
                // Implementation can be added later for visual feedback
                return;
            }

            function drawRotationArrows() {
                const arrowSize = 30;
                const cornerOffset = 15;
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                // Left top arrow (counter-clockwise)
                const leftX = cornerOffset + arrowSize / 2;
                const leftY = cornerOffset + arrowSize / 2;
                drawRotationArrow(leftX, leftY, "left");

                // Right top arrow (clockwise)
                const rightX = canvasWidth - cornerOffset - arrowSize / 2;
                const rightY = cornerOffset + arrowSize / 2;
                drawRotationArrow(rightX, rightY, "right");
            }

            function drawRotationArrow(x, y, direction) {
                const radius = 25;
                const isHovered = gameState.hoveredArrow === direction;

                ctx.save();

                // Draw background circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = isHovered
                    ? "rgba(78, 205, 196, 0.3)"
                    : "rgba(26, 26, 62, 0.9)";
                ctx.fill();

                // Draw border
                ctx.strokeStyle = isHovered ? "#ffdd44" : "#4ecdc4";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw the arrow symbol
                ctx.strokeStyle = isHovered ? "#ffdd44" : "#4ecdc4";
                ctx.fillStyle = isHovered ? "#ffdd44" : "#4ecdc4";
                ctx.lineWidth = 2.5;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                if (direction === "left") {
                    // Counter-clockwise: upward triangle on the left with arc connecting to bottom

                    // Draw upward-pointing triangle on the left
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y - 12); // Top point
                    ctx.lineTo(x - 12, y - 4); // Bottom left
                    ctx.lineTo(x - 4, y - 4); // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Draw arc connecting from triangle bottom, sweeping counter-clockwise
                    ctx.beginPath();
                    ctx.arc(x, y, 10, Math.PI * 1.2, Math.PI * 0.2, false);
                    ctx.stroke();
                } else {
                    // Clockwise: upward triangle on the right with arc connecting to bottom

                    // Draw upward-pointing triangle on the right
                    ctx.beginPath();
                    ctx.moveTo(x + 8, y - 12); // Top point
                    ctx.lineTo(x + 4, y - 4); // Bottom left
                    ctx.lineTo(x + 12, y - 4); // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Draw arc connecting from triangle bottom, sweeping clockwise
                    ctx.beginPath();
                    ctx.arc(x, y, 10, Math.PI * 0.8, Math.PI * 1.8, false);
                    ctx.stroke();
                }

                ctx.restore();
            }

            function startGrandAlignmentAnimation(wordDetails) {
                gameState.grandAlignmentAnimation.active = true;
                gameState.grandAlignmentAnimation.startTime = Date.now();
                gameState.grandAlignmentAnimation.particles = [];
                gameState.grandAlignmentAnimation.connectionLines = [];

                // Create spaceship animation data
                gameState.grandAlignmentAnimation.spaceship = {
                    angle: 0,
                    radius: 320,
                    x: gameState.center.x + 320,
                    y: gameState.center.y,
                    speed: 0.05, // radians per frame
                    bobOffset: 0,
                    trailParticles: [],
                };

                // Create connection lines for all aligned letters
                wordDetails.forEach((detail) => {
                    const position = detail.position;
                    const positionAngle = position * 30;
                    const oppositeAngle = (positionAngle + 180) % 360;

                    // Calculate line coordinates
                    const startX =
                        gameState.center.x +
                        300 * Math.cos(((positionAngle - 90) * Math.PI) / 180);
                    const startY =
                        gameState.center.y +
                        300 * Math.sin(((positionAngle - 90) * Math.PI) / 180);
                    const endX =
                        gameState.center.x +
                        300 * Math.cos(((oppositeAngle - 90) * Math.PI) / 180);
                    const endY =
                        gameState.center.y +
                        300 * Math.sin(((oppositeAngle - 90) * Math.PI) / 180);

                    gameState.grandAlignmentAnimation.connectionLines.push({
                        startX,
                        startY,
                        endX,
                        endY,
                        progress: 0,
                    });
                });

                // Create celebration particles
                for (let i = 0; i < 30; i++) {
                    gameState.grandAlignmentAnimation.particles.push(
                        createParticle(),
                    );
                }
            }

            function createParticle() {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                const life = 1.0;

                return {
                    x: gameState.center.x,
                    y: gameState.center.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: life,
                    maxLife: life,
                    size: 3 + Math.random() * 4,
                    color: ["#ffdd44", "#4ecdc4", "#ff6b6b", "#9945d1"][
                        Math.floor(Math.random() * 4)
                    ],
                };
            }

            function updateGrandAlignmentAnimation() {
                if (!gameState.grandAlignmentAnimation.active) return;

                const elapsed =
                    Date.now() - gameState.grandAlignmentAnimation.startTime;
                const progress = Math.min(
                    elapsed / gameState.grandAlignmentAnimation.duration,
                    1,
                );

                // Update celebration particles
                gameState.grandAlignmentAnimation.particles.forEach(
                    (particle) => {
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vy += 0.1; // Gravity
                        particle.life -= 0.02;

                        // Fade out
                        particle.life = Math.max(0, particle.life);
                    },
                );

                // Remove dead particles and add new ones
                gameState.grandAlignmentAnimation.particles =
                    gameState.grandAlignmentAnimation.particles.filter(
                        (p) => p.life > 0,
                    );

                // Keep adding particles for first 2 seconds
                if (elapsed < 2000 && Math.random() < 0.2) {
                    gameState.grandAlignmentAnimation.particles.push(
                        createParticle(),
                    );
                }

                // End animation
                if (progress >= 1) {
                    gameState.grandAlignmentAnimation.active = false;
                }
            }

            function drawGrandAlignmentAnimation() {
                if (!gameState.grandAlignmentAnimation.active) return;

                ctx.save();

                // Draw celebration particles
                gameState.grandAlignmentAnimation.particles.forEach(
                    (particle) => {
                        ctx.globalAlpha = particle.life / particle.maxLife;
                        ctx.fillStyle = particle.color;

                        ctx.beginPath();
                        ctx.arc(
                            particle.x,
                            particle.y,
                            particle.size,
                            0,
                            Math.PI * 2,
                        );
                        ctx.fill();
                    },
                );

                ctx.globalAlpha = 1;
                ctx.restore();
            }

            // Input handling
            canvas.addEventListener("mousedown", handleMouseDown);
            canvas.addEventListener("mousemove", handleMouseMove);
            canvas.addEventListener("mouseup", handleMouseUp);
            canvas.addEventListener("touchstart", handleTouchStart);
            canvas.addEventListener("touchmove", handleTouchMove);
            canvas.addEventListener("touchend", handleTouchEnd);

            // Keyboard controls
            document.addEventListener("keydown", handleKeyDown);

            // Rank board input handling
            showRanksDialogButton.addEventListener("click", () => {
                ranksDialog.showModal();
            });

            function handleKeyDown(e) {
                if (!gameState.selectedRing) return;

                switch (e.code) {
                    case "ArrowLeft":
                        e.preventDefault();
                        rotateRing(gameState.selectedRing, -1);
                        break;
                    case "ArrowRight":
                        e.preventDefault();
                        rotateRing(gameState.selectedRing, 1);
                        break;
                    case "ArrowUp":
                        e.preventDefault();
                        gameState.selectedRing = getNextRing(
                            gameState.selectedRing,
                        );
                        break;
                    case "ArrowDown":
                        e.preventDefault();
                        gameState.selectedRing = getPreviousRing(
                            gameState.selectedRing,
                        );
                        break;
                    case "Space":
                        e.preventDefault();
                        checkAllPositions();
                        break;
                }
            }

            function handleMouseDown(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                startDrag(x, y);
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // Check arrow hover
                const prevHoveredArrow = gameState.hoveredArrow;
                gameState.hoveredArrow = getHoveredArrow(x, y);

                // Update cursor
                if (gameState.hoveredArrow) {
                    canvas.style.cursor = "pointer";
                } else if (!gameState.dragState) {
                    canvas.style.cursor = "pointer";
                }

                // Redraw if hover state changed
                if (prevHoveredArrow !== gameState.hoveredArrow) {
                    // No need to call draw() here as it's called by animate()
                }

                updateDrag(x, y);
            }

            function handleMouseUp(e) {
                endDrag();
            }

            function handleTouchStart(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;
                startDrag(x, y);
            }

            function handleTouchMove(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;
                updateDrag(x, y);
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                endDrag();
            }

            function startDrag(x, y) {
                // Check if clicking on arrow first
                const clickedArrow = getHoveredArrow(x, y);
                if (clickedArrow) {
                    const rotation = clickedArrow === "left" ? -30 : 30;
                    rotateSystem(rotation);
                    return; // Don't start ring drag
                }

                // Existing ring selection logic
                const distance = Math.sqrt(
                    (x - gameState.center.x) ** 2 +
                        (y - gameState.center.y) ** 2,
                );

                let targetRing = null;
                let minDiff = Infinity;

                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    const diff = Math.abs(distance - ring.radius);
                    if (diff < 30 && diff < minDiff) {
                        minDiff = diff;
                        targetRing = ringName;
                    }
                });

                if (targetRing) {
                    gameState.selectedRing = targetRing;
                    const angle = Math.atan2(
                        y - gameState.center.y,
                        x - gameState.center.x,
                    );
                    gameState.dragState = {
                        ring: targetRing,
                        startAngle: angle,
                        startPosition: gameState.rings[targetRing].position,
                    };
                    canvas.style.cursor = "grabbing";
                } else {
                    gameState.selectedRing = null;
                }
            }

            function updateDrag(x, y) {
                if (!gameState.dragState) return;

                const angle = Math.atan2(
                    y - gameState.center.y,
                    x - gameState.center.x,
                );

                // Calculate the shortest angular distance
                let deltaAngle = angle - gameState.dragState.startAngle;

                // Normalize to [-œÄ, œÄ] range to prevent wrapping issues
                while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;

                const deltaPosition = (deltaAngle * 180) / Math.PI;
                let newPosition =
                    gameState.dragState.startPosition + deltaPosition;

                // Snap to nearest 30-degree increment
                newPosition = Math.round(newPosition / 30) * 30;

                gameState.rings[gameState.dragState.ring].targetPosition =
                    newPosition;
            }

            function endDrag() {
                gameState.dragState = null;
                canvas.style.cursor = "pointer";
            }

            function closeRanksDialog() {
                ranksDialog.close();
            }

            function calculateWordScore(word, hasSun = false) {
                let baseScore;
                const length = word.length;

                // Base scoring (Spelling Bee style)
                if (length === 3) {
                    baseScore = 1;
                } else {
                    baseScore = length; // 4+ letters get 1 point per letter
                }

                // Bonuses
                if (hasSun) baseScore += 1; // Sun letter bonus

                return baseScore;
            }

            function getRank(score) {
                for (let i = RANKS.length - 1; i >= 0; i--) {
                    if (score >= RANKS[i].min) {
                        return RANKS[i].name;
                    }
                }
                return "Beginner";
            }

            function updateScoreDisplay() {
                document.getElementById("playerScore").textContent =
                    gameState.score;
                document.getElementById("playerRank").textContent = getRank(
                    gameState.score,
                );
                document.getElementById("wordCount").textContent =
                    `${gameState.foundWords.size} words found`;
            }

            function updateRankHighlight() {
                const rank = getRank(gameState.score);

                if (rank != gameState.rank) {
                    // Remove current rank highlight from previous rank
                    const prevRankDialog =
                        document.querySelector(".current-rank");
                    prevRankDialog.classList.toggle("current-rank");

                    // Add current rank highlight to new rank
                    const newRankObj = RANKS.find((r) => r.name == rank);
                    const newRankDialog = document.querySelector(
                        `#${newRankObj.rankId}`,
                    );
                    newRankDialog.classList.toggle("current-rank");
                }
            }

            function rotateRing(ringName, direction) {
                const ring = gameState.rings[ringName];
                let newPosition = ring.targetPosition + direction * 30;

                ring.targetPosition = newPosition;
            }

            function rotateSystem(degrees) {
                gameState.systemRotation += degrees;

                // Keep rotation between 0-360
                while (gameState.systemRotation < 0)
                    gameState.systemRotation += 360;
                while (gameState.systemRotation >= 360)
                    gameState.systemRotation -= 360;

                // Rotate all rings by the specified amount
                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    ring.targetPosition += degrees;

                    // Keep positions normalized
                    while (ring.targetPosition < 0) ring.targetPosition += 360;
                    while (ring.targetPosition >= 360)
                        ring.targetPosition -= 360;
                });
            }

            function getLettersAtPosition(position) {
                const positionAngle = position * 30;
                const oppositeAngle = (positionAngle + 180) % 360;

                // Find letters at the position angle
                const positionLetters = [];
                // Find letters at the opposite angle
                const oppositeLetters = [];

                gameState.letters.forEach((letterObj) => {
                    const ringRotation =
                        gameState.rings[letterObj.ring].position;
                    const currentAngle = (letterObj.angle + ringRotation) % 360;
                    const normalizedCurrentAngle =
                        currentAngle < 0 ? currentAngle + 360 : currentAngle;

                    // Check if aligns with position angle
                    const positionDiff = Math.abs(
                        normalizedCurrentAngle - positionAngle,
                    );
                    const positionWrappedDiff = Math.min(
                        positionDiff,
                        360 - positionDiff,
                    );

                    if (positionWrappedDiff < 15) {
                        positionLetters.push({
                            letter: letterObj.letter,
                            radius: letterObj.radius,
                        });
                    }

                    // Check if aligns with opposite angle
                    const oppositeDiff = Math.abs(
                        normalizedCurrentAngle -
                            (oppositeAngle < 0
                                ? oppositeAngle + 360
                                : oppositeAngle),
                    );
                    const oppositeWrappedDiff = Math.min(
                        oppositeDiff,
                        360 - oppositeDiff,
                    );

                    if (oppositeWrappedDiff < 15) {
                        oppositeLetters.push({
                            letter: letterObj.letter,
                            radius: letterObj.radius,
                        });
                    }
                });

                // Add in blanks for positionLetters and oppositeLetters
                for (let radius of RING_RADII) {
                    if (
                        !positionLetters.some(
                            (letterObj) => letterObj.radius == radius,
                        )
                    ) {
                        positionLetters.push({
                            letter: " ",
                            radius,
                        });
                    }

                    if (
                        !oppositeLetters.some(
                            (letterObj) => letterObj.radius == radius,
                        )
                    ) {
                        oppositeLetters.push({
                            letter: " ",
                            radius,
                        });
                    }
                }

                // Sort position letters by radius (outermost to innermost)
                positionLetters.sort((a, b) => b.radius - a.radius);

                // Sort opposite letters by radius in reverse (innermost to outermost)
                oppositeLetters.sort((a, b) => a.radius - b.radius);

                // Build the sequence: position letters + sun + opposite letters
                const fullSequence = [];

                // Add position side letters
                positionLetters.forEach((item) =>
                    fullSequence.push(item.letter),
                );

                // Add sun in the middle
                fullSequence.push(gameState.sun.letter);

                // Add opposite side letters
                oppositeLetters.forEach((item) =>
                    fullSequence.push(item.letter),
                );

                return fullSequence;
            }

            function findWordsInAlignment(letters, position) {
                const words = [];
                const positionAngle = position * 30;

                // Determine reading direction based on sector
                const normalizedAngle = ((positionAngle % 360) + 360) % 360;
                const isVerticalSector =
                    normalizedAngle >= 315 ||
                    normalizedAngle <= 45 ||
                    (normalizedAngle >= 135 && normalizedAngle <= 225);

                // Check all possible starting positions and lengths in the ordered sequence
                // Determine if this word includes the sun
                const includesSun = letters.includes(gameState.sun.letter);

                // Check if this forms a valid word
                const potentialWords = letters.join("").trim().split(" ");
                for (const word of potentialWords) {
                    if (dictionary.has(word)) {
                        words.push({
                            word: word,
                            direction: isVerticalSector
                                ? "top-to-bottom"
                                : "left-to-right",
                            letters,
                            includesSun: includesSun,
                        });
                    }
                }

                // Remove duplicates based on word text
                const uniqueWords = [];
                const seen = new Set();
                words.forEach((wordObj) => {
                    if (!seen.has(wordObj.word)) {
                        seen.add(wordObj.word);
                        uniqueWords.push(wordObj);
                    }
                });

                return uniqueWords;
            }

            function checkAllPositions() {
                const allWords = [];
                const wordDetails = [];
                const positionsToCheck = [0, 1, 8, 9, 10, 11];
                let newWordsFound = false;
                let bonusScore = 0;

                for (let position of positionsToCheck) {
                    const letters = getLettersAtPosition(position);
                    const wordObjects = findWordsInAlignment(letters, position);

                    if (wordObjects.length > 0) {
                        // Add words found to allWords to check for bonuses later
                        wordObjects.forEach((wordObj) => {
                            allWords.push(wordObj.word);

                            // Calculate score for new words
                            if (!gameState.foundWords.has(wordObj.word)) {
                                newWordsFound = true;
                                const hasSun = wordObj.word.includes(
                                    gameState.sun.letter,
                                );
                                let wordScore = calculateWordScore(
                                    wordObj.word,
                                    hasSun,
                                );
                                gameState.score += wordScore;
                            }
                        });

                        wordDetails.push({
                            position: position,
                            letters: letters,
                            words: wordObjects,
                        });
                    }
                }

                // Add to word bank
                allWords.forEach((word) => {
                    gameState.foundWords.add(word);
                });

                if (newWordsFound) {
                    // Check for multi-word bonus at this position
                    const isMultiWord = allWords.length > 1;
                    const isGrandAlignment =
                        allWords.length == gameState.numWordsInGrandAlignment;

                    // 2 bonus points for each additional word found!
                    if (isMultiWord && !isGrandAlignment) {
                        bonusScore += 2 * (allWords.length - 1);
                    } else if (isGrandAlignment) {
                        bonusScore += 15;
                        // üéâ TRIGGER THE GRAND ALIGNMENT ANIMATION! üéâ
                        startGrandAlignmentAnimation(wordDetails);
                    }

                    // Apply all bonus scores (multi-word, grand alignment, etc)
                    gameState.score += bonusScore;

                    updateWordBank();
                    updateScoreDisplay();
                    updateRankHighlight();
                    updateLocalStorage();

                    // Brief score animation could go here
                    drawWordLines();
                    // TODO: Brief animation for score
                }
            }

            function updateWordBank() {
                const foundWordsEl = document.getElementById("foundWords");

                if (gameState.foundWords.size === 0) {
                    foundWordsEl.innerHTML =
                        "<em>Found words will appear here...</em>";
                } else {
                    foundWordsEl.innerHTML = "";

                    gameState.foundWords.forEach((word) => {
                        const wordEl = document.createElement("div");
                        wordEl.className = "word-item";
                        wordEl.textContent = word;
                        foundWordsEl.appendChild(wordEl);
                    });
                }
            }

            function updateLocalStorage() {
                window.localStorage.setItem(
                    LOCAL_STORAGE_KEY,
                    JSON.stringify({
                        gameId: gameState.gameId,
                        foundWords: [...gameState.foundWords], // Storing as array since Sets cannot be stored as JSON
                        score: gameState.score,
                    }),
                );
            }

            // Helper Functions
            function getNextRing(currentRing) {
                switch (currentRing) {
                    case "first":
                        return "second";
                    case "second":
                        return "third";
                    case "third":
                        return "fourth";
                    case "fourth":
                        return "fifth";
                    case "fifth":
                        return "first";
                    default:
                        return null;
                }
            }

            function getPreviousRing(currentRing) {
                switch (currentRing) {
                    case "first":
                        return "fifth";
                    case "second":
                        return "first";
                    case "third":
                        return "second";
                    case "fourth":
                        return "third";
                    case "fifth":
                        return "fourth";
                    default:
                        return null;
                }
            }

            function getHoveredArrow(x, y) {
                const arrowRadius = 25;
                const cornerOffset = 15;
                const arrowSize = 30;

                // Left arrow position
                const leftX = cornerOffset + arrowSize / 2;
                const leftY = cornerOffset + arrowSize / 2;

                // Right arrow position
                const rightX = canvas.width - cornerOffset - arrowSize / 2;
                const rightY = cornerOffset + arrowSize / 2;

                // Check left arrow
                const leftDist = Math.sqrt((x - leftX) ** 2 + (y - leftY) ** 2);
                if (leftDist <= arrowRadius) {
                    return "left";
                }

                // Check right arrow
                const rightDist = Math.sqrt(
                    (x - rightX) ** 2 + (y - rightY) ** 2,
                );
                if (rightDist <= arrowRadius) {
                    return "right";
                }

                return null;
            }

            function shufflePlanets() {
                const rings = gameState.rings;
                for (let ring of Object.keys(rings)) {
                    let randomRotation = 30 * Math.floor(12 * Math.random());
                    rings[ring].targetPosition += randomRotation;
                }
            }

            function initializeRanks() {
                const goodPoints = document.getElementById("goodPoints");
                const greatPoints = document.getElementById("greatPoints");
                const voyagerPoints = document.getElementById("voyagerPoints");
                const stellarPoints = document.getElementById("stellarPoints");
                const redGiantPoints =
                    document.getElementById("redGiantPoints");
                const whiteDwarfPoints =
                    document.getElementById("whiteDwarfPoints");
                const supernovaPoints =
                    document.getElementById("supernovaPoints");
                const neutronStarPoints =
                    document.getElementById("neutronStarPoints");
                const blackHolePoints =
                    document.getElementById("blackHolePoints");

                goodPoints.textContent = RANKS[1].min + " points";
                greatPoints.textContent = RANKS[2].min + " points";
                voyagerPoints.textContent = RANKS[3].min + " points";
                stellarPoints.textContent = RANKS[4].min + " points";
                redGiantPoints.textContent = RANKS[5].min + " points";
                whiteDwarfPoints.textContent = RANKS[6].min + " points";
                supernovaPoints.textContent = RANKS[7].min + " points";
                neutronStarPoints.textContent = RANKS[8].min + " points";
                blackHolePoints.textContent = RANKS[9].min + "+ points";
            }

            function getSavedGameState() {
                const prevGameState =
                    window.localStorage.getItem(LOCAL_STORAGE_KEY);

                // If no state, set to starting state for day
                if (!prevGameState) {
                    window.localStorage.setItem(
                        LOCAL_STORAGE_KEY,
                        JSON.stringify({
                            gameId: gameState.gameId,
                            foundWords: [], // Storing as array since Sets cannot be stored as JSON
                            score: 0,
                        }),
                    );
                } else {
                    const parsedPrevGameState = JSON.parse(prevGameState);

                    // Clear old state if game id doesn't match current:
                    if (parsedPrevGameState.gameId != gameState.gameId) {
                        window.localStorage.setItem(
                            LOCAL_STORAGE_KEY,
                            JSON.stringify({
                                gameId: gameState.gameId,
                                foundWords: [], // Storing as array since Sets cannot be stored as JSON
                                score: 0,
                            }),
                        );
                    } else {
                        // Convert foundWords array to Set
                        const foundWordsSet = new Set(
                            parsedPrevGameState.foundWords,
                        );
                        gameState = {
                            ...gameState,
                            foundWords: foundWordsSet,
                            score: parsedPrevGameState.score,
                        };

                        // Show previous state!
                        updateWordBank();
                    }
                }
            }

            function openHelpDialog() {
                const dialog = document.getElementById("helpDialog");
                dialog.showModal();
            }

            function closeHelpDialog() {
                const dialog = document.getElementById("helpDialog");
                dialog.classList.add("closing");

                setTimeout(() => {
                    dialog.close();
                    dialog.classList.remove("closing");
                }, 300);
            }

            // Close on backdrop click
            document
                .getElementById("helpDialog")
                .addEventListener("click", (e) => {
                    if (e.target.tagName === "DIALOG") {
                        closeHelpDialog();
                    }
                });

            function initializeGame() {
                getSavedGameState();
                updateScoreDisplay();
                initializeRanks();
                shufflePlanets();
                animate();
            }

            // Start the game!
            initializeGame();
        </script>
    </body>
</html>
