<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Solar Word Game - Canvas Version</title>
        <style>
            body {
                margin: 0;
                padding: 20px;
                background: #0a0a2e;
                color: white;
                font-family: Arial, sans-serif;
                min-height: 100vh;
            }

            .game-layout {
                display: flex;
                gap: 20px;
                max-width: 1200px;
                margin: 0 auto;
                align-items: flex-start;
            }

            .game-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .sidebar {
                width: 300px;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .score-panel {
                background: #1a1a3e;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
            }

            .score-panel h2 {
                margin: 0 0 10px 0;
                font-size: 28px;
                color: #ffdd44;
            }

            .rank {
                font-size: 18px;
                color: #4ecdc4;
                margin-bottom: 5px;
            }

            .score {
                font-size: 16px;
                color: #ccc;
            }

            .word-bank {
                background: #1a1a3e;
                border-radius: 8px;
                padding: 20px;
                flex: 1;
            }

            .word-bank h3 {
                margin: 0 0 15px 0;
                text-align: center;
            }

            #gameCanvas {
                border: 2px solid #444;
                border-radius: 10px;
                cursor: pointer;
                background: radial-gradient(
                    circle at center,
                    #1a1a4e 0%,
                    #0a0a2e 70%
                );
            }

            .controls {
                margin: 20px 0;
                text-align: center;
                max-width: 500px;
            }

            .instructions {
                margin: 20px 0;
                padding: 15px;
                background: #1a1a3e;
                border-radius: 8px;
                max-width: 500px;
                font-size: 14px;
                text-align: center;
            }

            .keyboard-hint {
                background: #2a2a5e;
                border-radius: 4px;
                padding: 10px;
                font-size: 12px;
                margin-top: 10px;
            }

            button {
                margin: 0 5px;
                padding: 8px 16px;
                background: #444;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            }

            button:hover {
                background: #666;
            }

            .check-button {
                background: #28a745 !important;
                font-size: 14px;
                padding: 10px 20px;
                margin: 0 10px;
            }

            .found-words {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 10px;
            }

            .word-item {
                background: #2a2a5e;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 14px;
            }

            .results {
                margin: 20px 0;
                padding: 15px;
                background: #2a2a5e;
                border-radius: 8px;
                max-width: 500px;
                font-size: 14px;
                line-height: 1.5;
            }

            @media (max-width: 768px) {
                .game-layout {
                    flex-direction: column;
                }

                .sidebar {
                    width: 100%;
                    order: -1;
                }

                .score-panel {
                    display: flex;
                    justify-content: space-around;
                    align-items: center;
                    text-align: left;
                }
            }
        </style>
    </head>
    <body>
        <h1 style="text-align: center; margin-bottom: 30px">Solar Word Game</h1>

        <div class="game-layout">
            <div class="game-area">
                <div class="instructions">
                    <strong>How to play:</strong> Click on an orbital ring to
                    select it, then use arrow keys to rotate. You can also click
                    and drag rings to rotate them. Find words by aligning
                    letters!

                    <div class="keyboard-hint">
                        <strong>Keyboard controls:</strong><br />
                        Click ring and press arrows keys to rotate<br />
                        Space bar to check for words
                    </div>
                </div>

                <canvas id="gameCanvas" width="600" height="600"></canvas>

                <div class="controls">
                    <button class="check-button" onclick="checkAllPositions()">
                        Check for Words (Space)
                    </button>
                    <!-- <button onclick="toggleAutoCheck()">
                        Auto-Check: <span id="autoCheckStatus">OFF</span>
                    </button> -->
                    <button onclick="runFindAllPossibleWords()">
                        Get All Words
                    </button>
                </div>
            </div>

            <div class="sidebar">
                <div class="score-panel">
                    <div>
                        <h2 id="playerScore">0</h2>
                        <div class="rank" id="playerRank">Beginner</div>
                        <div class="score" id="wordCount">0 words found</div>
                    </div>
                </div>

                <div class="word-bank">
                    <h3>Word Bank</h3>
                    <div class="found-words" id="foundWords">
                        <em>Found words will appear here...</em>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Constants - Ring diameters, colors, etc.
            const FIRST_RING_COLOR = "#ff6b6b";
            const SECOND_RING_COLOR = "#297a23";
            const THIRD_RING_COLOR = "#45b7d1";
            const FOURTH_RING_COLOR = "#9945d1";
            const FIFTH_RING_COLOR = "#9e297b";

            const FIRST_RING_RADIUS = 60;
            const SECOND_RING_RADIUS = 110;
            const THIRD_RING_RADIUS = 160;
            const FOURTH_RING_RADIUS = 210;
            const FIFTH_RING_RADIUS = 260;

            const RING_RADII = [
                FIRST_RING_RADIUS,
                SECOND_RING_RADIUS,
                THIRD_RING_RADIUS,
                FOURTH_RING_RADIUS,
                FIFTH_RING_RADIUS,
            ];

            // Game state - now with flexible letter positioning
            const gameState = {
                letters: [
                    // First ring
                    {
                        letter: "F",
                        radius: FIRST_RING_RADIUS,
                        angle: 0,
                        color: FIRST_RING_COLOR,
                        ring: "inner",
                    },
                    // {
                    //     letter: "A",
                    //     radius: FIRST_RING_RADIUS,
                    //     angle: 60,
                    //     color: FIRST_RING_COLOR,
                    //     ring: "inner",
                    // },
                    {
                        letter: "I",
                        radius: FIRST_RING_RADIUS,
                        angle: 120,
                        color: FIRST_RING_COLOR,
                        ring: "inner",
                    },
                    {
                        letter: "O",
                        radius: FIRST_RING_RADIUS,
                        angle: 180,
                        color: FIRST_RING_COLOR,
                        ring: "inner",
                    },
                    // {
                    //     letter: "I",
                    //     radius: FIRST_RING_RADIUS,
                    //     angle: 240,
                    //     color: FIRST_RING_COLOR,
                    //     ring: "inner",
                    // },
                    {
                        letter: "U",
                        radius: FIRST_RING_RADIUS,
                        angle: 300,
                        color: FIRST_RING_COLOR,
                        ring: "inner",
                    },

                    // Second ring
                    {
                        letter: "S",
                        radius: SECOND_RING_RADIUS,
                        angle: 30,
                        color: SECOND_RING_COLOR,
                        ring: "middle",
                    },
                    // {
                    //     letter: "C",
                    //     radius: SECOND_RING_RADIUS,
                    //     angle: 60,
                    //     color: SECOND_RING_COLOR,
                    //     ring: "middle",
                    // },
                    {
                        letter: "R",
                        radius: SECOND_RING_RADIUS,
                        angle: 90,
                        color: SECOND_RING_COLOR,
                        ring: "middle",
                    },
                    {
                        letter: "P",
                        radius: SECOND_RING_RADIUS,
                        angle: 120,
                        color: SECOND_RING_COLOR,
                        ring: "middle",
                    },
                    {
                        letter: "W",
                        radius: SECOND_RING_RADIUS,
                        angle: 180,
                        color: SECOND_RING_COLOR,
                        ring: "middle",
                    },
                    {
                        letter: "L",
                        radius: SECOND_RING_RADIUS,
                        angle: 210,
                        color: SECOND_RING_COLOR,
                        ring: "middle",
                    },
                    // {
                    //     letter: "L",
                    //     radius: SECOND_RING_RADIUS,
                    //     angle: 240,
                    //     color: SECOND_RING_COLOR,
                    //     ring: "middle",
                    // },
                    {
                        letter: "T",
                        radius: SECOND_RING_RADIUS,
                        angle: 300,
                        color: SECOND_RING_COLOR,
                        ring: "middle",
                    },

                    // Third ring
                    {
                        letter: "I",
                        radius: THIRD_RING_RADIUS,
                        angle: 30,
                        color: THIRD_RING_COLOR,
                        ring: "outer",
                    },
                    {
                        letter: "O",
                        radius: THIRD_RING_RADIUS,
                        angle: 90,
                        color: THIRD_RING_COLOR,
                        ring: "outer",
                    },
                    {
                        letter: "E",
                        radius: THIRD_RING_RADIUS,
                        angle: 180,
                        color: THIRD_RING_COLOR,
                        ring: "outer",
                    },
                    {
                        letter: "I",
                        radius: THIRD_RING_RADIUS,
                        angle: 210,
                        color: THIRD_RING_COLOR,
                        ring: "outer",
                    },

                    // Fourth ring
                    {
                        letter: "R",
                        radius: FOURTH_RING_RADIUS,
                        angle: 30,
                        color: FOURTH_RING_COLOR,
                        ring: "fourth",
                    },
                    {
                        letter: "S",
                        radius: FOURTH_RING_RADIUS,
                        angle: 90,
                        color: FOURTH_RING_COLOR,
                        ring: "fourth",
                    },
                    {
                        letter: "R",
                        radius: FOURTH_RING_RADIUS,
                        angle: 180,
                        color: FOURTH_RING_COLOR,
                        ring: "fourth",
                    },
                    {
                        letter: "L",
                        radius: FOURTH_RING_RADIUS,
                        angle: 210,
                        color: FOURTH_RING_COLOR,
                        ring: "fourth",
                    },

                    // Fifth ring
                    {
                        letter: "I",
                        radius: FIFTH_RING_RADIUS,
                        angle: 30,
                        color: FIFTH_RING_COLOR,
                        ring: "fifth",
                    },
                    {
                        letter: "E",
                        radius: FIFTH_RING_RADIUS,
                        angle: 90,
                        color: FIFTH_RING_COLOR,
                        ring: "fifth",
                    },
                    {
                        letter: "Y",
                        radius: FIFTH_RING_RADIUS,
                        angle: 210,
                        color: FIFTH_RING_COLOR,
                        ring: "fifth",
                    },
                ],
                rings: {
                    inner: {
                        position: 0,
                        targetPosition: 0,
                        radius: FIRST_RING_RADIUS,
                        color: FIRST_RING_COLOR,
                    },
                    middle: {
                        position: 0,
                        targetPosition: 0,
                        radius: SECOND_RING_RADIUS,
                        color: SECOND_RING_COLOR,
                    },
                    outer: {
                        position: 0,
                        targetPosition: 0,
                        radius: THIRD_RING_RADIUS,
                        color: THIRD_RING_COLOR,
                    },
                    fourth: {
                        position: 0,
                        targetPosition: 0,
                        radius: FOURTH_RING_RADIUS,
                        color: FOURTH_RING_COLOR,
                    },
                    fifth: {
                        position: 0,
                        targetPosition: 0,
                        radius: FIFTH_RING_RADIUS,
                        color: FIFTH_RING_COLOR,
                    },
                },
                shuffled: false,
                foundWords: new Set(),
                numWordsInGrandAlignment: 5,
                score: 0,
                maxScore: 142,
                autoCheck: false,
                dragState: null,
                selectedRing: null,
                center: { x: 300, y: 300 },
                sun: { letter: "L", radius: 20, color: "#ffdd44" },
            };

            // Word list
            async function loadDictionary() {
                try {
                    const response = await fetch("./valid_words.txt");
                    const text = await response.text();

                    const words = text
                        .split("\n")
                        .map((word) => word.trim().toUpperCase())
                        .filter(
                            (word) => word.length >= 3 && word.length <= 11,
                        );

                    console.log(`Loaded ${words.length} words`);
                    return new Set(words);
                } catch (error) {
                    console.error("Failed to load dictionary:", error);
                    return new Set(["SPACE", "STAR", "PLANET"]); // Fallback
                }
            }
            let dictionary;
            loadDictionary().then((raw_dictionary) => {
                dictionary = raw_dictionary;
            });

            // Canvas setup
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // Animation loop
            function animate() {
                update();
                draw();
                requestAnimationFrame(animate);
            }

            function update() {
                // Smooth rotation animations with proper wraparound handling
                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    let diff = ring.targetPosition - ring.position;

                    // Handle wraparound: choose the shortest angular path
                    while (diff > 180) diff -= 360;
                    while (diff < -180) diff += 360;

                    if (Math.abs(diff) > 0.01) {
                        ring.position += diff * 0.15; // Smooth interpolation
                    }
                });

                // Auto-check if enabled
                if (gameState.autoCheck) {
                    checkAllPositions();
                }
            }

            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw orbital rings (guidelines)
                drawOrbitalRings();

                // Draw reading direction indicators
                drawReadingIndicators();

                // Shuffle planets
                shufflePlanets();

                // Draw planets
                drawPlanets();

                // Draw sun
                drawSun();

                // Draw any word visualization
                drawWordLines();
            }

            function drawOrbitalRings() {
                // Draw rings based on unique radii from letters
                const radii = [
                    ...new Set(
                        Object.values(gameState.rings).map(
                            (ring) => ring.radius,
                        ),
                    ),
                ];
                radii.forEach((radius) => {
                    const ringName = Object.keys(gameState.rings).find(
                        (name) => gameState.rings[name].radius === radius,
                    );
                    const isSelected = gameState.selectedRing === ringName;

                    ctx.strokeStyle = isSelected ? "#ffdd44" : "#444";
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.setLineDash(isSelected ? [] : [5, 5]);

                    ctx.beginPath();
                    ctx.arc(
                        gameState.center.x,
                        gameState.center.y,
                        radius,
                        0,
                        Math.PI * 2,
                    );
                    ctx.stroke();
                });

                ctx.setLineDash([]);
            }

            function drawReadingIndicators() {
                ctx.strokeStyle = "#666";
                ctx.lineWidth = 1;
                ctx.font = "10px Arial";
                ctx.fillStyle = "#888";

                // Draw subtle lines at all 12 positions
                for (let pos = 0; pos < 8; pos++) {
                    const angle = ((pos * 45 - 90) * Math.PI) / 180;

                    if (pos % 2 === 1) {
                        // Show main positions (12, 3, 6, 9)
                        const x1 = gameState.center.x + 60 * Math.cos(angle);
                        const y1 = gameState.center.y + 60 * Math.sin(angle);
                        const x2 = gameState.center.x + 300 * Math.cos(angle);
                        const y2 = gameState.center.y + 300 * Math.sin(angle);

                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = "#ffdd44";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            }

            function drawPlanets() {
                gameState.letters.forEach((letterObj) => {
                    // Calculate current position based on ring rotation
                    const ringRotation =
                        (gameState.rings[letterObj.ring].position * Math.PI) /
                        180;
                    const totalAngle =
                        (letterObj.angle * Math.PI) / 180 +
                        ringRotation -
                        Math.PI / 2;

                    const x =
                        gameState.center.x +
                        letterObj.radius * Math.cos(totalAngle);
                    const y =
                        gameState.center.y +
                        letterObj.radius * Math.sin(totalAngle);

                    // Planet body
                    ctx.fillStyle = letterObj.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.fill();

                    // Planet border
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Letter
                    ctx.fillStyle = "white";
                    ctx.font = "bold 22px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(letterObj.letter, x, y);
                });
            }

            function drawSun() {
                const sun = gameState.sun;

                // Sun glow
                const gradient = ctx.createRadialGradient(
                    gameState.center.x,
                    gameState.center.y,
                    0,
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius + 10,
                );
                gradient.addColorStop(0, "#ffdd44");
                gradient.addColorStop(0.7, "#ffaa00");
                gradient.addColorStop(1, "rgba(255, 170, 0, 0)");

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius + 10,
                    0,
                    Math.PI * 2,
                );
                ctx.fill();

                // Sun body
                ctx.fillStyle = sun.color;
                ctx.beginPath();
                ctx.arc(
                    gameState.center.x,
                    gameState.center.y,
                    sun.radius,
                    0,
                    Math.PI * 2,
                );
                ctx.fill();

                // Sun border
                ctx.strokeStyle = "#ffaa00";
                ctx.lineWidth = 3;
                ctx.stroke();

                // Sun letter
                ctx.fillStyle = "#333";
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(
                    gameState.sun.letter,
                    gameState.center.x,
                    gameState.center.y,
                );
            }

            function drawWordLines() {
                // This will show visual connections for found words
                // Implementation can be added later for visual feedback
            }

            // Input handling
            canvas.addEventListener("mousedown", handleMouseDown);
            canvas.addEventListener("mousemove", handleMouseMove);
            canvas.addEventListener("mouseup", handleMouseUp);
            canvas.addEventListener("touchstart", handleTouchStart);
            canvas.addEventListener("touchmove", handleTouchMove);
            canvas.addEventListener("touchend", handleTouchEnd);

            // Keyboard controls
            document.addEventListener("keydown", handleKeyDown);

            function handleKeyDown(e) {
                if (!gameState.selectedRing) return;

                switch (e.code) {
                    case "ArrowLeft":
                        e.preventDefault();
                        rotateRing(gameState.selectedRing, -1);
                        break;
                    case "ArrowRight":
                        e.preventDefault();
                        rotateRing(gameState.selectedRing, 1);
                        break;
                    case "ArrowUp":
                        e.preventDefault();
                        gameState.selectedRing = getNextRing(
                            gameState.selectedRing,
                        );
                        break;
                    case "ArrowDown":
                        e.preventDefault();
                        gameState.selectedRing = getPrevoiusRing(
                            gameState.selectedRing,
                        );
                        break;
                    case "Space":
                        e.preventDefault();
                        checkAllPositions();
                        break;
                }
            }

            function handleMouseDown(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                startDrag(x, y);
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                updateDrag(x, y);
            }

            function handleMouseUp(e) {
                endDrag();
            }

            function handleTouchStart(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                startDrag(x, y);
            }

            function handleTouchMove(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                updateDrag(x, y);
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                endDrag();
            }

            function startDrag(x, y) {
                const distance = Math.sqrt(
                    (x - gameState.center.x) ** 2 +
                        (y - gameState.center.y) ** 2,
                );

                // Determine which ring is being clicked
                let targetRing = null;
                let minDiff = Infinity;

                Object.keys(gameState.rings).forEach((ringName) => {
                    const ring = gameState.rings[ringName];
                    const diff = Math.abs(distance - ring.radius);
                    if (diff < 30 && diff < minDiff) {
                        // 30px tolerance
                        minDiff = diff;
                        targetRing = ringName;
                    }
                });

                if (targetRing) {
                    // Select the ring
                    gameState.selectedRing = targetRing;

                    // Start drag for rotation
                    const angle = Math.atan2(
                        y - gameState.center.y,
                        x - gameState.center.x,
                    );
                    gameState.dragState = {
                        ring: targetRing,
                        startAngle: angle,
                        startPosition: gameState.rings[targetRing].position,
                    };
                    canvas.style.cursor = "grabbing";
                } else {
                    // Click on empty space deselects
                    gameState.selectedRing = null;
                }
            }

            function updateDrag(x, y) {
                if (!gameState.dragState) return;

                const angle = Math.atan2(
                    y - gameState.center.y,
                    x - gameState.center.x,
                );

                // Calculate the shortest angular distance
                let deltaAngle = angle - gameState.dragState.startAngle;

                // Normalize to [-π, π] range to prevent wrapping issues
                while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;

                const deltaPosition = (deltaAngle * 180) / Math.PI;
                let newPosition =
                    gameState.dragState.startPosition + deltaPosition;

                // Snap to nearest 30-degree increment
                newPosition = Math.round(newPosition / 30) * 30;

                gameState.rings[gameState.dragState.ring].targetPosition =
                    newPosition;
            }

            function endDrag() {
                gameState.dragState = null;
                canvas.style.cursor = "pointer";
            }

            // Scoring system
            const RANKS = [
                { name: "Beginner", min: 0 },
                { name: "Good", min: Math.floor(gameState.maxScore * 0.1) },
                { name: "Great", min: Math.floor(gameState.maxScore * 0.2) },
                { name: "Voyager", min: Math.floor(gameState.maxScore * 0.3) },
                { name: "Stellar", min: Math.floor(gameState.maxScore * 0.4) },
                {
                    name: "Red Giant",
                    min: Math.floor(gameState.maxScore * 0.5),
                },
                {
                    name: "White Dwarf",
                    min: Math.floor(gameState.maxScore * 0.6),
                },
                {
                    name: "Supernova",
                    min: Math.floor(gameState.maxScore * 0.7),
                },
                {
                    name: "Neutron Star",
                    min: Math.floor(gameState.maxScore * 0.8),
                },
                { name: "Black Hole", min: gameState.maxScore },
            ];

            function calculateWordScore(word, hasSun = false) {
                let baseScore;
                const length = word.length;

                // Base scoring (Spelling Bee style)
                if (length === 3) {
                    baseScore = 1;
                } else if (length === 4) {
                    baseScore = 2;
                } else {
                    baseScore = length; // 5+ letters get 1 point per letter
                }

                // Bonuses
                if (hasSun) baseScore += 1; // Sun letter bonus

                return baseScore;
            }

            function getRank(score) {
                for (let i = RANKS.length - 1; i >= 0; i--) {
                    if (score >= RANKS[i].min) {
                        return RANKS[i].name;
                    }
                }
                return "Beginner";
            }

            function updateScoreDisplay() {
                document.getElementById("playerScore").textContent =
                    gameState.score;
                document.getElementById("playerRank").textContent = getRank(
                    gameState.score,
                );
                document.getElementById("wordCount").textContent =
                    `${gameState.foundWords.size} words found`;
            }

            function rotateRing(ringName, direction) {
                const ring = gameState.rings[ringName];
                let newPosition = ring.targetPosition + direction * 30;

                ring.targetPosition = newPosition;
            }

            function getLettersAtPosition(position) {
                const positionAngle = position * 30;
                const oppositeAngle = (positionAngle + 180) % 360;

                // Find letters at the position angle
                const positionLetters = [];
                // Find letters at the opposite angle
                const oppositeLetters = [];

                gameState.letters.forEach((letterObj) => {
                    const ringRotation =
                        gameState.rings[letterObj.ring].position;
                    const currentAngle = (letterObj.angle + ringRotation) % 360;
                    const normalizedCurrentAngle =
                        currentAngle < 0 ? currentAngle + 360 : currentAngle;

                    // Check if aligns with position angle
                    const positionDiff = Math.abs(
                        normalizedCurrentAngle - positionAngle,
                    );
                    const positionWrappedDiff = Math.min(
                        positionDiff,
                        360 - positionDiff,
                    );

                    if (positionWrappedDiff < 15) {
                        positionLetters.push({
                            letter: letterObj.letter,
                            radius: letterObj.radius,
                        });
                    }

                    // Check if aligns with opposite angle
                    const oppositeDiff = Math.abs(
                        normalizedCurrentAngle -
                            (oppositeAngle < 0
                                ? oppositeAngle + 360
                                : oppositeAngle),
                    );
                    const oppositeWrappedDiff = Math.min(
                        oppositeDiff,
                        360 - oppositeDiff,
                    );

                    if (oppositeWrappedDiff < 15) {
                        oppositeLetters.push({
                            letter: letterObj.letter,
                            radius: letterObj.radius,
                        });
                    }
                });

                // Add in blanks for positionLetters and oppositeLetters
                for (let radius of RING_RADII) {
                    if (
                        !positionLetters.some(
                            (letterObj) => letterObj.radius == radius,
                        )
                    ) {
                        positionLetters.push({
                            letter: " ",
                            radius,
                        });
                    }

                    if (
                        !oppositeLetters.some(
                            (letterObj) => letterObj.radius == radius,
                        )
                    ) {
                        oppositeLetters.push({
                            letter: " ",
                            radius,
                        });
                    }
                }

                // Sort position letters by radius (outermost to innermost)
                positionLetters.sort((a, b) => b.radius - a.radius);

                // Sort opposite letters by radius in reverse (innermost to outermost)
                oppositeLetters.sort((a, b) => a.radius - b.radius);

                // Build the sequence: position letters + sun + opposite letters
                const fullSequence = [];

                // Add position side letters
                positionLetters.forEach((item) =>
                    fullSequence.push(item.letter),
                );

                // Add sun in the middle
                fullSequence.push(gameState.sun.letter);

                // Add opposite side letters
                oppositeLetters.forEach((item) =>
                    fullSequence.push(item.letter),
                );

                return fullSequence;
            }

            function findWordsInAlignment(letters, position) {
                const words = [];
                const positionAngle = position * 30;

                // Determine reading direction based on sector
                const normalizedAngle = ((positionAngle % 360) + 360) % 360;
                const isVerticalSector =
                    normalizedAngle >= 315 ||
                    normalizedAngle <= 45 ||
                    (normalizedAngle >= 135 && normalizedAngle <= 225);

                // Check all possible starting positions and lengths in the ordered sequence
                // Determine if this word includes the sun
                const includesSun = letters.includes(gameState.sun.letter);

                // Check if this forms a valid word
                const potentialWords = letters.join("").trim().split(" ");
                for (const word of potentialWords) {
                    if (dictionary.has(word)) {
                        words.push({
                            word: word,
                            direction: isVerticalSector
                                ? "top-to-bottom"
                                : "left-to-right",
                            letters,
                            includesSun: includesSun,
                        });
                    }
                }

                // Remove duplicates based on word text
                const uniqueWords = [];
                const seen = new Set();
                words.forEach((wordObj) => {
                    if (!seen.has(wordObj.word)) {
                        seen.add(wordObj.word);
                        uniqueWords.push(wordObj);
                    }
                });

                return uniqueWords;
            }

            function checkAllPositions() {
                const allWords = [];
                const wordDetails = [];
                const positionsToCheck = [0, 1, 8, 9, 10, 11];
                let newWordsFound = false;

                for (let position of positionsToCheck) {
                    const letters = getLettersAtPosition(position);
                    const wordObjects = findWordsInAlignment(letters, position);

                    if (wordObjects.length > 0) {
                        // Check for multi-word bonus at this position
                        const isMultiWord = wordObjects.length > 1;
                        const isGrandAlignment =
                            wordObjects.length ==
                            gameState.numWordsInGrandAlignment;

                        // 2 bonus points for each additional word found!
                        let bonusScore = 0;
                        if (wordObjects.length > 1 && !isGrandAlignment) {
                            bonusScore +=
                                2 *
                                (gameState.numWordsInGrandAlignment -
                                    wordObjects.length);
                        } else if (isGrandAlignment) bonusScore += 15;

                        wordObjects.forEach((wordObj) => {
                            allWords.push(wordObj.word);

                            // Calculate score for new words
                            if (!gameState.foundWords.has(wordObj.word)) {
                                newWordsFound = true;
                                const hasSun = wordObj.word.includes(
                                    gameState.sun.letter,
                                );
                                let wordScore = calculateWordScore(
                                    wordObj.word,
                                    hasSun,
                                );
                                wordScore += bonusScore;
                                gameState.score += wordScore;
                            }
                        });

                        wordDetails.push({
                            position: position,
                            letters: letters,
                            words: wordObjects,
                        });
                    }
                }

                // Add to word bank
                allWords.forEach((word) => {
                    gameState.foundWords.add(word);
                });

                updateWordBank();
                updateScoreDisplay();

                if (newWordsFound) {
                    // Brief score animation could go here
                }
            }

            function toggleAutoCheck() {
                gameState.autoCheck = !gameState.autoCheck;
                document.getElementById("autoCheckStatus").textContent =
                    gameState.autoCheck ? "ON" : "OFF";
            }

            function updateWordBank() {
                const foundWordsEl = document.getElementById("foundWords");

                if (gameState.foundWords.size === 0) {
                    foundWordsEl.innerHTML =
                        "<em>Found words will appear here...</em>";
                } else {
                    foundWordsEl.innerHTML = "";

                    // Sort words by length, then alphabetically
                    const sortedWords = [...gameState.foundWords].sort(
                        (a, b) => {
                            if (a.length !== b.length)
                                return a.length - b.length;
                            return a.localeCompare(b);
                        },
                    );

                    sortedWords.forEach((word) => {
                        const wordEl = document.createElement("div");
                        wordEl.className = "word-item";
                        wordEl.textContent = word;
                        foundWordsEl.appendChild(wordEl);
                    });
                }
            }

            // Helper Functions
            function getNextRing(currentRing) {
                switch (currentRing) {
                    case "inner":
                        return "middle";
                    case "middle":
                        return "outer";
                    case "outer":
                        return "fourth";
                    case "fourth":
                        return "fifth";
                    case "fifth":
                        return "inner";
                    default:
                        return null;
                }
            }

            function getPrevoiusRing(currentRing) {
                switch (currentRing) {
                    case "inner":
                        return "fifth";
                    case "middle":
                        return "inner";
                    case "outer":
                        return "middle";
                    case "fourth":
                        return "outer";
                    case "fifth":
                        return "fourth";
                    default:
                        return null;
                }
            }

            function shufflePlanets() {
                if (!gameState.shuffled) {
                    const rings = gameState.rings;
                    for (let ring of Object.keys(rings)) {
                        let randomRotation =
                            30 * Math.floor(12 * Math.random());
                        rings[ring].targetPosition += randomRotation;
                    }
                    gameState.shuffled = true;
                }
            }

            // Initialize the game
            updateScoreDisplay();
            animate();
        </script>
    </body>
</html>
